{"title":"SQL语句性能分析工具 - explain","uid":"91a0e294ae045d1c9047e0525f52b4fd","slug":"01_MySQL/Explain","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.990Z","comments":true,"path":"api/articles/01_MySQL/Explain.json","keywords":null,"cover":[],"content":"<p>通过explain，如以下例子：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;</code></pre>\n\n<table>\n<thead>\n<tr>\n<th align=\"left\">id</th>\n<th align=\"left\">select_type</th>\n<th align=\"left\">table</th>\n<th align=\"left\">partitions</th>\n<th align=\"left\">type</th>\n<th align=\"left\">possible_keys</th>\n<th align=\"left\">key</th>\n<th align=\"left\">key_len</th>\n<th align=\"left\">ref</th>\n<th align=\"left\">filtered</th>\n<th align=\"left\">rows</th>\n<th align=\"left\">Extra</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">SIMPLE</td>\n<td align=\"left\">titles</td>\n<td align=\"left\">null</td>\n<td align=\"left\">const</td>\n<td align=\"left\">PRIMARY</td>\n<td align=\"left\">PRIMARY</td>\n<td align=\"left\">59</td>\n<td align=\"left\">const,const,const</td>\n<td align=\"left\">10</td>\n<td align=\"left\">1</td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>id：在⼀个⼤的查询语句中每个<strong>SELECT</strong>关键字都对应⼀个唯⼀的id ，如</p>\n<p><code>explain select * from s1 where id = (select id from s1 where name = &#39;egon1&#39;);</code></p>\n<p>第一个select的id是1，第二个select的id是2。</p>\n<p>有时候会出现两个select，但是id却都是1，</p>\n<p>这是因为优化器把子查询变成了连接查询 。</p>\n</li>\n<li><p>select_type：select关键字对应的那个查询的类型，如</p>\n<p><img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/select_type.png\" alt=\"图片\"></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">类型</th>\n<th align=\"left\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">SIMPLE</td>\n<td align=\"left\">简单SELECT查询，不包含子查询和UNION</td>\n</tr>\n<tr>\n<td align=\"left\">PRIMARY</td>\n<td align=\"left\">复杂查询中的最外层查询，表示主要的查询</td>\n</tr>\n<tr>\n<td align=\"left\">SUBQUERY</td>\n<td align=\"left\">SELECT或WHERE列表中包含了子查询</td>\n</tr>\n<tr>\n<td align=\"left\">DERIVED</td>\n<td align=\"left\">FROM列表中包含的子查询，即衍生</td>\n</tr>\n<tr>\n<td align=\"left\">UNION</td>\n<td align=\"left\">UNION关键字之后的查询</td>\n</tr>\n<tr>\n<td align=\"left\">UNION RESULT</td>\n<td align=\"left\">从UNION后的表获取结果集</td>\n</tr>\n</tbody></table>\n</li>\n<li><p>table：每个查询对应的表名 </p>\n<ul>\n<li><code>&lt;unionM,N&gt;</code>：具有和id值的行的M并集N。</li>\n<li><code>&lt;derivedN&gt;</code>：用于与该行的派生表结果id的值N。派生表可能来自（例如）FROM子句中的子查询 。</li>\n<li><code>&lt;subqueryN&gt;</code>：子查询的结果，其id值为N</li>\n</ul>\n</li>\n<li><p>partitions：该列的值表示查询将从中匹配记录的分区</p>\n</li>\n<li><p>type：<code>type</code> 字段比较重要, 它提供了判断查询是否高效的重要依据依据.</p>\n<p>通过 <code>type</code> 字段, 我们判断此次查询是 <code>全表扫描</code> 还是 <code>索引扫描</code> 等。如</p>\n<p>const(主键索引或者唯一二级索引进行等值匹配的情况下)；</p>\n<p>ref(普通的⼆级索引列与常量进⾏等值匹配)；</p>\n<p>index(扫描全表索引的覆盖索引) …<img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/explain_type.png\" alt=\"图片\"></p>\n<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>\n<p>通常来说, 不同的 type 类型的性能关系如下:</p>\n<p><code>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system</code></p>\n<p><code>ALL</code> 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.而 <code>index</code> 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.</p>\n</li>\n<li><p>possible_key：查询中可能用到的索引(可以把用不到的删掉，降低优化器的优化时间)</p>\n</li>\n<li><p>key：此字段是 MySQL 在当前查询时所真正使用到的索引。</p>\n</li>\n<li><p>key_len：该列表示使用索引的长度。</p>\n</li>\n<li><p>ref：该列表示索引命中的列或者常量。</p>\n</li>\n<li><p>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好。</p>\n</li>\n<li><p>filtered：查询器预测满足下一次查询条件的百分比 。</p>\n</li>\n<li><p>extra：表示额外信息，如Using where,Start temporary,End temporary,Using temporary等。</p>\n<table>\n<thead>\n<tr>\n<th>枚举值</th>\n<th>涵义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Impossible WHERE</td>\n<td>表示WHERE后面的条件一直都是false</td>\n</tr>\n<tr>\n<td>Using filesort</td>\n<td>表示按文件排序，一般是在指定的排序和索引排序不一致的情况才会出现</td>\n</tr>\n<tr>\n<td>Using index</td>\n<td>表示是否用了覆盖索引，说白了它表示是否所有获取的列都走了索引</td>\n</tr>\n<tr>\n<td>Using temporary</td>\n<td>表示是否使用了临时表，一般多见于order by 和 group by语句</td>\n</tr>\n<tr>\n<td>Using where</td>\n<td>表示使用了where条件过滤</td>\n</tr>\n<tr>\n<td>Using join buffer</td>\n<td>表示是否使用连接缓冲</td>\n</tr>\n<tr>\n<td>No tables used</td>\n<td>Query语句中使用from dual 或不含任何from子句</td>\n</tr>\n<tr>\n<td>Select tables optimized away</td>\n<td>这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<p>常用的字符编码占用字节数量如下：</p>\n<p><img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/bite.png\" alt=\"图片\"></p>\n<p>目前我的数据库字符编码格式用的：UTF8占3个字节。</p>\n<p>MySQL常用字段占用字节数：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">字段类型</th>\n<th align=\"left\">占用字节数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">char(n)</td>\n<td align=\"left\">n</td>\n</tr>\n<tr>\n<td align=\"left\">varchar(n)</td>\n<td align=\"left\">n + 2</td>\n</tr>\n<tr>\n<td align=\"left\">tinyint</td>\n<td align=\"left\">1</td>\n</tr>\n<tr>\n<td align=\"left\">smallint</td>\n<td align=\"left\">2</td>\n</tr>\n<tr>\n<td align=\"left\">int</td>\n<td align=\"left\">4</td>\n</tr>\n<tr>\n<td align=\"left\">bigint</td>\n<td align=\"left\">8</td>\n</tr>\n<tr>\n<td align=\"left\">date</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">timestamp</td>\n<td align=\"left\">4</td>\n</tr>\n<tr>\n<td align=\"left\">datetime</td>\n<td align=\"left\">8</td>\n</tr>\n</tbody></table>\n<p>使用<code>explain</code>命令，查看<code>MySQL</code>的执行计划。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">项目</th>\n<th align=\"center\">释义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">id</td>\n<td align=\"center\">select唯一标识</td>\n</tr>\n<tr>\n<td align=\"center\">select_type</td>\n<td align=\"center\">select类型</td>\n</tr>\n<tr>\n<td align=\"center\">table</td>\n<td align=\"center\">表名称</td>\n</tr>\n<tr>\n<td align=\"center\">partitions</td>\n<td align=\"center\">匹配的分区</td>\n</tr>\n<tr>\n<td align=\"center\">type</td>\n<td align=\"center\">连接类型</td>\n</tr>\n<tr>\n<td align=\"center\">possible_keys</td>\n<td align=\"center\">可能的索引选择</td>\n</tr>\n<tr>\n<td align=\"center\">key</td>\n<td align=\"center\">实际用到的索引</td>\n</tr>\n<tr>\n<td align=\"center\">key_len</td>\n<td align=\"center\">实际索引长度</td>\n</tr>\n<tr>\n<td align=\"center\">ref</td>\n<td align=\"center\">与索引比较的列</td>\n</tr>\n<tr>\n<td align=\"center\">rows</td>\n<td align=\"center\">预期要检查的行数</td>\n</tr>\n<tr>\n<td align=\"center\">filtered</td>\n<td align=\"center\">按表条件过滤的行百分比</td>\n</tr>\n<tr>\n<td align=\"center\">extra</td>\n<td align=\"center\">附加信息</td>\n</tr>\n</tbody></table>\n<h2 id=\"索引优化的过程\"><a href=\"#索引优化的过程\" class=\"headerlink\" title=\"索引优化的过程\"></a>索引优化的过程</h2><ol>\n<li><p>先用慢查询日志定位具体需要优化的sql</p>\n</li>\n<li><p>使用explain执行计划查看索引使用情况</p>\n</li>\n<li><p>重点关注：</p>\n<p>key（查看有没有使用索引）</p>\n<p>key_len（查看索引使用是否充分）</p>\n<p>type（查看索引类型）</p>\n<p>extra（查看附加信息：排序、临时表、where条件为false等）</p>\n<p>一般情况下根据这4列就能找到索引问题。</p>\n</li>\n<li><p>根据上1步找出的索引问题优化sql</p>\n</li>\n<li><p>再回到第2步</p>\n</li>\n</ol>\n","text":"通过explain，如以下例子： EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39; AND from_...","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E7%9A%84%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">索引优化的过程</span></a></li></ol>","author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"MySQL - MVCC","uid":"ef9e2edc26d3ded046b353bb82c77d51","slug":"01_MySQL/MVCC","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.990Z","comments":true,"path":"api/articles/01_MySQL/MVCC.json","keywords":null,"cover":[],"text":"MVCC叫做多版本控制，实现MVCC时用到了一致性视图，用于支持读提交和可重复读的实现。 对于一行数据若是想实现可重复读取或者能够读取数据的另一个事务未提交前的原始值，那么必须对原始数据进行保存或者对更新操作进行保存，这样才能够查询到原始值。 在Mysql的MVCC中规定每一行数...","link":"","photos":[],"count_time":{"symbolsCount":469,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"MySQL主从复制与读写分离","uid":"e7f5587de2fa0cb9394ae0921cbff0fa","slug":"01_MySQL/主从读写","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.991Z","comments":true,"path":"api/articles/01_MySQL/主从读写.json","keywords":null,"cover":[],"text":" 主从同步 master主库，有数据更新，将此次更新的事件类型写入到主库的binlog文件中 主库会创建log dump 线程通知slave有数据更新 slave从库，向master节点的 log dump线程请求一份指定binlog文件位置的副本，并将请求回来的binlog存到...","link":"","photos":[],"count_time":{"symbolsCount":973,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}