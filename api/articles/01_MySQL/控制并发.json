{"title":"控制并发","uid":"f9a9c6facd4e5bfb5a48d022643ffd1d","slug":"01_MySQL/控制并发","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.992Z","comments":true,"path":"api/articles/01_MySQL/控制并发.json","keywords":null,"cover":null,"content":"<p>Mysql内部通过锁机制实现对资源的并发访问控制，保证数据的一致性，锁机制的类型和引擎的种类有关，MyISAM中默认支持的表级锁有两种：共享读锁和独占写锁。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。</p>\n<h4 id=\"MyISAM锁机制\"><a href=\"#MyISAM锁机制\" class=\"headerlink\" title=\"MyISAM锁机制\"></a>MyISAM锁机制</h4><p>Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">&#x2F;&#x2F; 显式的添加表级读锁\nLOCK TABLE 表名 READ\n&#x2F;&#x2F; 显示的添加表级写锁\nLOCK TABLE 表名 WRITE\n&#x2F;&#x2F; 显式的解锁（当一个事务commit的时候也会自动解锁）\nunlock tables;</code></pre>\n\n<p>（1）MyISAM表级写锁：当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作。</p>\n<p>（2）MyISAM表级共享读锁：当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁。</p>\n<h4 id=\"InnoDB锁机制\"><a href=\"#InnoDB锁机制\" class=\"headerlink\" title=\"InnoDB锁机制\"></a>InnoDB锁机制</h4><p>InnoDB和MyISAM不同的是，InnoDB支持行锁和事务，InnoDB中除了有表锁和行级锁的概念，还有Gap Lock（间隙锁）、Next-key Lock锁，间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案。</p>\n<p>InnoDB中的行级锁是对索引加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁。</p>\n<p>但是通过索引查询的时候是否使用索引，还要看Mysql的执行计划，Mysql的优化器会判断是一条sql执行的最佳策略。</p>\n<p>若是Mysql觉得执行索引查询还不如全表扫描速度快，那么Mysql就会使用全表扫描来查询，这是即使sql语句中使用了索引，最后还是执行为全表扫描，加的是表锁。</p>\n","text":"Mysql内部通过锁机制实现对资源的并发访问控制，保证数据的一致性，锁机制的类型和引擎的种类有关，MyISAM中默认支持的表级锁有两种：共享读锁和独占写锁。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。 MyISAM锁机制Mysql中可以...","link":"","photos":[],"count_time":{"symbolsCount":757,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MyISAM%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">MyISAM锁机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#InnoDB%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">InnoDB锁机制</span></a></li></ol>","author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"分库分表","uid":"fb7e30301338d92aa2ed33accfcc50d6","slug":"01_MySQL/分库分表","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.991Z","comments":true,"path":"api/articles/01_MySQL/分库分表.json","keywords":null,"cover":null,"text":" 分库分表 ​ 并发量决定是否需要分库， ​ 数据量决定是否需要分表。 分区分片 ​ 按时间范围归档分区 ​ 按用户ID取模分表， ​ 按shardingkey来分片； 数据量太大的场景 mysql表的数据量一般控制在千万级别，如果再大的话，就要考虑分库分表。 除了分表外，列举了...","link":"","photos":[],"count_time":{"symbolsCount":740,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"HTTP","uid":"f89d86da12057f40e1f8accda509e042","slug":"03_HTTP/HTTP","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.011Z","comments":true,"path":"api/articles/03_HTTP/HTTP.json","keywords":null,"cover":[],"text":"什么是HTTP? 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP&#x2F;IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 HTTP特点： 无状态...","link":"","photos":[],"count_time":{"symbolsCount":555,"symbolsTime":"1 mins."},"categories":[{"name":"网络编程","slug":"网络编程","count":9,"path":"api/categories/网络编程.json"}],"tags":[{"name":"HTTP","slug":"HTTP","count":5,"path":"api/tags/HTTP.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}