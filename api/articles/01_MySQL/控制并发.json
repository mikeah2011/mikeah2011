{"title":"控制并发","uid":"f9a9c6facd4e5bfb5a48d022643ffd1d","slug":"01_MySQL/控制并发","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.992Z","comments":true,"path":"api/articles/01_MySQL/控制并发.json","keywords":null,"cover":null,"content":"<p>Mysql内部通过锁机制实现对资源的并发访问控制，保证数据的一致性，锁机制的类型和引擎的种类有关，MyISAM中默认支持的表级锁有两种：共享读锁和独占写锁。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。</p>\n<h4 id=\"MyISAM锁机制\"><a href=\"#MyISAM锁机制\" class=\"headerlink\" title=\"MyISAM锁机制\"></a>MyISAM锁机制</h4><p>Mysql中可以通过以下sql来显示的在事务中显式的进行加锁和解锁操作：</p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">&#x2F;&#x2F; 显式的添加表级读锁\nLOCK TABLE 表名 READ\n&#x2F;&#x2F; 显示的添加表级写锁\nLOCK TABLE 表名 WRITE\n&#x2F;&#x2F; 显式的解锁（当一个事务commit的时候也会自动解锁）\nunlock tables;</code></pre>\n\n<p>（1）MyISAM表级写锁：当一个线程获取到表级写锁后，只能由该线程对表进行读写操作，别的线程必须等待该线程释放锁以后才能操作。</p>\n<p>（2）MyISAM表级共享读锁：当一个线程获取到表级读锁后，该线程只能读取数据不能修改数据，其它线程也只能加读锁，不能加写锁。</p>\n<h4 id=\"InnoDB锁机制\"><a href=\"#InnoDB锁机制\" class=\"headerlink\" title=\"InnoDB锁机制\"></a>InnoDB锁机制</h4><p>InnoDB和MyISAM不同的是，InnoDB支持行锁和事务，InnoDB中除了有表锁和行级锁的概念，还有Gap Lock（间隙锁）、Next-key Lock锁，间隙锁主要用于范围查询的时候，锁住查询的范围，并且间隙锁也是解决幻读的方案。</p>\n<p>InnoDB中的行级锁是对索引加的锁，在不通过索引查询数据的时候，InnoDB就会使用表锁。</p>\n<p>但是通过索引查询的时候是否使用索引，还要看Mysql的执行计划，Mysql的优化器会判断是一条sql执行的最佳策略。</p>\n<p>若是Mysql觉得执行索引查询还不如全表扫描速度快，那么Mysql就会使用全表扫描来查询，这是即使sql语句中使用了索引，最后还是执行为全表扫描，加的是表锁。</p>\n","text":"Mysql内部通过锁机制实现对资源的并发访问控制，保证数据的一致性，锁机制的类型和引擎的种类有关，MyISAM中默认支持的表级锁有两种：共享读锁和独占写锁。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。 MyISAM锁机制Mysql中可以...","link":"","photos":[],"count_time":{"symbolsCount":757,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#MyISAM%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">MyISAM锁机制</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#InnoDB%E9%94%81%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">InnoDB锁机制</span></a></li></ol>","author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/","zhihu":"https://www.zhihu.com/people/","csdn":"https://blog.csdn.net/","juejin":"https://juejin.cn/user/","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/"},"facebook":{"icon":"iconfont icon-facebook","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"分库分表","uid":"fb7e30301338d92aa2ed33accfcc50d6","slug":"01_MySQL/分库分表","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.991Z","comments":true,"path":"api/articles/01_MySQL/分库分表.json","keywords":null,"cover":null,"text":" 分库分表 ​ 并发量决定是否需要分库， ​ 数据量决定是否需要分表。 分区分片 ​ 按时间范围归档分区 ​ 按用户ID取模分表， ​ 按shardingkey来分片； 数据量太大的场景 mysql表的数据量一般控制在千万级别，如果再大的话，就要考虑分库分表。 除了分表外，列举了...","link":"","photos":[],"count_time":{"symbolsCount":740,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/","zhihu":"https://www.zhihu.com/people/","csdn":"https://blog.csdn.net/","juejin":"https://juejin.cn/user/","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/"},"facebook":{"icon":"iconfont icon-facebook","link":"https://facebook.com"}}}}},"next_post":{"title":"Redis缓存击穿","uid":"406c5d5fe6c6fd475c83074ee629ccea","slug":"02_Redis/缓存击穿","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.010Z","comments":true,"path":"api/articles/02_Redis/缓存击穿.json","keywords":null,"cover":null,"text":"什么是缓存击穿？ 其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。 分析： 关键在于某个热点的key失效了，导致大并发集中...","link":"","photos":[],"count_time":{"symbolsCount":321,"symbolsTime":"1 mins."},"categories":[{"name":"Redis","slug":"Redis","count":10,"path":"api/categories/Redis.json"}],"tags":[{"name":"redis","slug":"redis","count":10,"path":"api/tags/redis.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/","zhihu":"https://www.zhihu.com/people/","csdn":"https://blog.csdn.net/","juejin":"https://juejin.cn/user/","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/"},"facebook":{"icon":"iconfont icon-facebook","link":"https://facebook.com"}}}}}}