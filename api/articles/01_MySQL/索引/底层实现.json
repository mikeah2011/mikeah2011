{"title":"索引底层实现","uid":"71464c5902369f580d83a42e959c47ea","slug":"01_MySQL/索引/底层实现","date":"2015-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.994Z","comments":true,"path":"api/articles/01_MySQL/索引/底层实现.json","keywords":null,"cover":[],"content":"<p><strong>Hash索引</strong></p>\n<p>基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。</p>\n<p><img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/644.png\" alt=\"图片\"></p>\n<p><strong>B-Tree索引</strong>（MySQL使用B+Tree）</p>\n<p>B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p>\n<p><img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/6410.png\" alt=\"图片\"></p>\n<p><strong>B+Tree索引</strong></p>\n<p>是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。</p>\n<p>B+tree性质：</p>\n<ul>\n<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>\n<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>\n<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>\n<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>\n<li>B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>\n</ul>\n<p><img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/6402.png\" alt=\"图片\"></p>\n<blockquote>\n</blockquote>\n","text":"Hash索引 基于哈希表实现，只有精确匹配索引所有列的查询才有效，对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），并且Hash索引将所有的哈希码存储在索引中，同时在索引表中保存指向每个数据行的指针。 B-Tree索引（MySQL使用B+Tree） ...","link":"","photos":[],"count_time":{"symbolsCount":554,"symbolsTime":"1 mins."},"categories":[{"name":"索引","slug":"索引","count":14,"path":"api/categories/索引.json"}],"tags":[{"name":"索引","slug":"索引","count":15,"path":"api/tags/索引.json"}],"toc":"","author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/","zhihu":"https://www.zhihu.com/people/","csdn":"https://blog.csdn.net/","juejin":"https://juejin.cn/user/","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/"},"facebook":{"icon":"iconfont icon-facebook","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"前缀索引","uid":"9e33d627513d69088c1f528c1caaca12","slug":"01_MySQL/索引/前缀索引","date":"2015-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.993Z","comments":true,"path":"api/articles/01_MySQL/索引/前缀索引.json","keywords":null,"cover":null,"text":"因为可能我们索引的字段非常长，这既占内存空间，也不利于维护。所以我们就想，如果只把很长字段的前面的公共部分作为一个索引，就会产生超级加倍的效果。但是，我们需要注意，order by不支持前缀索引 。 流程是： 先计算完整列的选择性 :select count(distinct c...","link":"","photos":[],"count_time":{"symbolsCount":304,"symbolsTime":"1 mins."},"categories":[{"name":"索引","slug":"索引","count":14,"path":"api/categories/索引.json"}],"tags":[{"name":"索引","slug":"索引","count":15,"path":"api/tags/索引.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/","zhihu":"https://www.zhihu.com/people/","csdn":"https://blog.csdn.net/","juejin":"https://juejin.cn/user/","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/"},"facebook":{"icon":"iconfont icon-facebook","link":"https://facebook.com"}}}}},"next_post":{}}