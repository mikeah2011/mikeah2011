{"title":"索引采用的算法","uid":"127d1f6ddaf592cdbfe5766a891f8f96","slug":"01_MySQL/索引/B+树","date":"2020-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.993Z","comments":true,"path":"api/articles/01_MySQL/索引/B+树.json","keywords":null,"cover":null,"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>索引为什么采用B+树，而不用B-树，红黑树</p></blockquote>\n<p>提升查询速度，首先要减少磁盘I&#x2F;O次数，也就是要降低树的高度。</p>\n<ul>\n<li><p>平衡二叉树、红黑树，都属于二叉树。</p>\n<p>时间复杂度为O(n)，当表的数据量上千万时，树的深度很深，mysql读取时消耗大量 IO。</p>\n<p>另外，InnoDB引擎采用<code>页</code>为单位读取，每个节点一页，</p>\n<p>但是二叉树每个节点储存一个关键词，导致空间浪费。</p>\n</li>\n<li><p>B-树，非叶子节点存储数据，占用较多空间，</p>\n<p>导致每个节点的<code>指针</code>少很多，无形增加了树的深度。</p>\n</li>\n<li><p>B+树数据都存储在叶子节点，非叶子节点只存储<code>健值+指针</code>，</p>\n<p>索引树更加扁平，三层深度可以支持千万级表存储。</p>\n<p>同时叶子节点之间通过链表关联，范围查找更快。</p>\n</li>\n</ul>\n","text":" 索引为什么采用B+树，而不用B-树，红黑树 提升查询速度，首先要减少磁盘I&#x2F;O次数，也就是要降低树的高度。 平衡二叉树、红黑树，都属于二叉树。 时间复杂度为O(n)，当表的数据量上千万时，树的深度很深，mysql读取时消耗大量 IO。 另外，InnoDB引擎采用页为单...","link":"","photos":[],"count_time":{"symbolsCount":312,"symbolsTime":"1 mins."},"categories":[{"name":"索引","slug":"索引","count":14,"path":"api/categories/索引.json"}],"tags":[{"name":"索引","slug":"索引","count":15,"path":"api/tags/索引.json"}],"toc":"","author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> <br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"https://stackoverflow.com/users/11422545/mikeah2011","wechat":"","qq":"","weibo":"https://weibo.com/u/2383628417","zhihu":"https://www.zhihu.com/people/michael-12-18","csdn":"https://blog.csdn.net/weixin_41273562","juejin":"https://juejin.cn/user/4389711549044269","customs":{}}},"mapped":true,"prev_post":{"title":"Git基础","uid":"7972c32d39f314ccb6f804289f8a291c","slug":"SVN/Git","date":"2020-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.025Z","comments":true,"path":"api/articles/SVN/Git.json","keywords":null,"cover":null,"text":"GIT 以行的模式查看提交日志： git log –pretty&#x3D;oneline 撤销某次提交，并保留修改 –soft git reset –soft d3c2257b08ffefd69130d9e2bdd1d0328c7d4085 将修改暂存到缓存区保存起来： git...","link":"","photos":[],"count_time":{"symbolsCount":359,"symbolsTime":"1 mins."},"categories":[{"name":"git","slug":"git","count":1,"path":"api/categories/git.json"}],"tags":[{"name":"git","slug":"git","count":1,"path":"api/tags/git.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> <br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"https://stackoverflow.com/users/11422545/mikeah2011","wechat":"","qq":"","weibo":"https://weibo.com/u/2383628417","zhihu":"https://www.zhihu.com/people/michael-12-18","csdn":"https://blog.csdn.net/weixin_41273562","juejin":"https://juejin.cn/user/4389711549044269","customs":{}}}},"next_post":{"title":"Redis缓存击穿","uid":"406c5d5fe6c6fd475c83074ee629ccea","slug":"02_Redis/缓存击穿","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.010Z","comments":true,"path":"api/articles/02_Redis/缓存击穿.json","keywords":null,"cover":null,"text":"什么是缓存击穿？ 其实跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。 分析： 关键在于某个热点的key失效了，导致大并发集中...","link":"","photos":[],"count_time":{"symbolsCount":321,"symbolsTime":"1 mins."},"categories":[{"name":"Redis","slug":"Redis","count":10,"path":"api/categories/Redis.json"}],"tags":[{"name":"redis","slug":"redis","count":10,"path":"api/tags/redis.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://cdn.jsdelivr.net/gh/mikeah2011/oss@main/uPic/blog_logo.jpeg","link":"/","description":"知我所能者，我所能者，尽善尽美；<br/> <br/> 知我所不能者，我所不能者，虚怀若谷。","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"https://stackoverflow.com/users/11422545/mikeah2011","wechat":"","qq":"","weibo":"https://weibo.com/u/2383628417","zhihu":"https://www.zhihu.com/people/michael-12-18","csdn":"https://blog.csdn.net/weixin_41273562","juejin":"https://juejin.cn/user/4389711549044269","customs":{}}}}}