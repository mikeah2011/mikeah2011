{"title":"常见的设计模式","uid":"1a2ade4f8c304fc2bc170e0b21a2a998","slug":"05_PHP/常见设计模式","date":"2021-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.017Z","comments":true,"path":"api/articles/05_PHP/常见设计模式.json","keywords":null,"cover":null,"content":"<table>\n<thead>\n<tr>\n<th align=\"center\">设计模式</th>\n<th align=\"center\">概念</th>\n<th align=\"center\">代码</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">工厂模式</td>\n<td align=\"center\">用来实现创建对象和对象的使用分离，将对象的创建交给专门的工厂类负责<br />简单工厂模式<br />工厂模式<br />抽象工厂模式</td>\n<td align=\"center\">简单工厂模式，根据不同的入参new实例化不同的类对象</td>\n</tr>\n<tr>\n<td align=\"center\">单例模式</td>\n<td align=\"center\">保证一个类仅有一个实例，并提供一个访问它的全局访问点。</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">适配器模式</td>\n<td align=\"center\">将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">观察者模式</td>\n<td align=\"center\">定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，简单来说该模式相当于源 - 监听（Source-Listener）模式（即监听器）、发布 - 订阅（Publish-Subscribe）模式</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">策略模式</td>\n<td align=\"center\">用相同的方法实现不同的功能</td>\n<td align=\"center\"></td>\n</tr>\n<tr>\n<td align=\"center\">注册树模式</td>\n<td align=\"center\"></td>\n<td align=\"center\"></td>\n</tr>\n</tbody></table>\n","text":" 设计模式 概念 代码 工厂模式 用来实现创建对象和对象的使用分离，将对象的创建交给专门的工厂类负责简单工厂模式工厂模式抽象工厂模式 简单工厂模式，根据不同的入参new实例化不同的类对象 单例模式 保证一个类仅有一个实例，并提供一个访问它的全局访问点。 适配器模式 将一个类的接口...","link":"","photos":[],"count_time":{"symbolsCount":367,"symbolsTime":"1 mins."},"categories":[{"name":"PHP","slug":"PHP","count":24,"path":"api/categories/PHP.json"}],"tags":[{"name":"设计模式","slug":"设计模式","count":1,"path":"api/tags/设计模式.json"}],"toc":"","author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"Redis高并发","uid":"b8997c28f0beb7e2efaf414b6b406c0f","slug":"02_Redis/防止高并发","date":"2021-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.011Z","comments":true,"path":"api/articles/02_Redis/防止高并发.json","keywords":null,"cover":null,"text":" 背景 Redis是不会存在并发问题的，因为他是单进程的，再多的命令都是一个接一个地执行的。 场景 GET &amp; SET 利用Jedis等客户端对Redis进行并发访问 远程访问Redis的时候，因为网络等原因造成高并发访问、延迟返回 我们使用的时候，可能会出现并发问题，比...","link":"","photos":[],"count_time":{"symbolsCount":561,"symbolsTime":"1 mins."},"categories":[{"name":"Redis","slug":"Redis","count":10,"path":"api/categories/Redis.json"}],"tags":[{"name":"redis","slug":"redis","count":10,"path":"api/tags/redis.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"PHP依赖注入","uid":"dd3ad8310bb65f7ae1074f767c58a90d","slug":"05_PHP/依赖注入","date":"2021-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.017Z","comments":true,"path":"api/articles/05_PHP/依赖注入.json","keywords":null,"cover":null,"text":"依赖注入 IOC（inversion of control） 控制反转模式；控制反转是将组件间的依赖关系从程序内部提到外部来管理； DI（dependency injection）依赖注入模式； 依赖注入是指将组件的依赖通过外部以 参数或其他形式 注入； ","link":"","photos":[],"count_time":{"symbolsCount":128,"symbolsTime":"1 mins."},"categories":[{"name":"PHP","slug":"PHP","count":24,"path":"api/categories/PHP.json"}],"tags":[{"name":"PHP","slug":"PHP","count":11,"path":"api/tags/PHP.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}