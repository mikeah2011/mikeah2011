{"title":"Redis","uid":"a978a5e93d8e6628e9f4ee713be55be8","slug":"02_Redis/Redis","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.000Z","comments":true,"path":"api/articles/02_Redis/Redis.json","keywords":null,"cover":[],"content":"<p>为了便于大家查找问题，了解全貌，整理个目录，我们可以快速全局了解关于Redis 缓存，面试官一般喜欢问哪些问题？</p>\n<p><img src=\"/mikeah2011/Users/michael/Project/MichaelBlog/images/redis_all.png\" alt=\"图片\"></p>\n<p>接下来，我们逐条来看看每个问题及答案</p>\n<p><strong>Redis 有哪些特性？</strong></p>\n<p>答案：</p>\n<ul>\n<li>性能高， 读的速度是100000次&#x2F;s，写的速度是80000次&#x2F;s</li>\n<li>数据持久化，支持RDB 、AOF</li>\n<li>支持事务。通过<code>MULTI</code>和<code>EXEC</code>指令包起来。</li>\n<li>多种数据结构类型</li>\n<li>主从复制</li>\n<li>其他特性：发布&#x2F;订阅、通知、key过期等</li>\n</ul>\n<p><strong>Redis 为什么这么快？</strong></p>\n<p>答案：</p>\n<ul>\n<li>完全基于内存，没有磁盘IO上的开销，异步持久化除外</li>\n<li>单线程，避免多个线程切换的性能损耗</li>\n<li>非阻塞的IO多路复用机制</li>\n<li>底层的数据存储结构优化，使用原生的数据结构提升性能。</li>\n</ul>\n<p><strong>Redis 底层的基础数据结构有哪些？</strong></p>\n<p>答案：</p>\n<ul>\n<li>字符串。没有采用C语言的传统字符串，而是自己实现的一个简单动态字符串SDS的抽象类型，并保存了长度信息。</li>\n<li>链表（linkedlist）。双向无环链表结构，每个链表的节点由一个listNode结构来表示，每个节点都有前置和后置节点的指针</li>\n<li>字典（hashtable）。保存键值对的抽象数据结构，底层使用hash表，每个字典带有两个hash表，供平时使用和rehash时使用。</li>\n<li>跳跃表（skiplist）。跳跃表是有序集合的底层实现之一。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表 信息(表头、表尾节点、⻓度等)，zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1- 32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。</li>\n<li>整数集合（intset）。用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。</li>\n<li>压缩列表（ziplist）。为节约内存而开发的顺序性数据结构，可以包含多个节点，每个节点可以保存一个字节数组或者整数值。</li>\n</ul>\n<p><strong>Redis 支持哪些数据类型？</strong></p>\n<p>答案：五种常用数据类型：<code>String</code>、<code>Hash</code>、<code>Set</code>、<code>List</code>、<code>SortedSet</code>。三种特殊的数据类型：<code>Bitmap</code>、<code>HyperLogLog</code>、<code>Geospatial</code>，其中Bitmap 、HyperLogLog的底层都是 String 数据类型，Geospatial 底层是 Sorted Set 数据类型。</p>\n<ul>\n<li>字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串</li>\n<li>列表对象list：ziplist、linkedlist</li>\n<li>哈希对象hash：ziplist、hashtable</li>\n<li>集合对象set：intset、hashtable</li>\n<li>有序集合对象zset：ziplist、skiplist</li>\n</ul>\n<p><strong>Redis 常用的 5 种数据结构和应用场景？</strong></p>\n<p>答案：</p>\n<ul>\n<li>String：缓存、计数器、分布式锁等</li>\n<li>List：链表、队列、微博关注人时间轴列表等</li>\n<li>Hash：用户信息、Hash 表等</li>\n<li>Set：去重、赞、踩、共同好友等</li>\n<li>Zset：访问量排行榜、点击量排行榜等</li>\n</ul>\n<p><strong>为什么采用单线程？</strong></p>\n<p>答案：官方回复，CPU不会成为Redis的制约瓶颈，Redis主要受内存、网络限制。例如，在一个普通的 Linux 系统上，使用pipelining 可以每秒传递 100 万个请求，所以如果您的应用程序主要使用 O(N) 或 O(log(N)) 命令，则几乎不会使用太多 CPU，属于IO密集型系统。</p>\n<p><strong>Redis 6.0 之后又改用多线程呢?</strong></p>\n<p>答案：Redis的多线程主要是处理数据的读写、协议解析。执行命令还是采用单线程顺序执行。</p>\n<p>主要是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程进行一些周边预处理，提升了IO的读写效率，从而提高了整体的吞吐量。antirez 在 RedisConf 2019 分享时提到，Redis 6 引入的多线程 IO 对性能提升至少一倍以上。</p>\n<p><strong>过期键Key 的删除策略有哪些？</strong></p>\n<p>答案：有3种过期删除策略。惰性删除、定期删除、定时删除</p>\n<ul>\n<li>惰性删除。使用key时才进行检查，如果已经过期，则删除。缺点：过期的key如果没有被访问到，一直无法删除，一直占用内存，造成空间浪费。</li>\n<li>定期删除。每隔一段时间做一次检查，删除过期的key，每次只是随机取一些key去检查。</li>\n<li>定时删除。为每个key设置过期时间，同时创建一个定时器。一旦到期，立即执行删除。缺点：如果过期键比较多时，占用CPU较多，对服务的性能有很大影响。</li>\n</ul>\n<p><strong>如果Redis的内存空间不足，淘汰机制？</strong></p>\n<p>答案：</p>\n<ul>\n<li>volatile-lru：从已设置过期时间的key中，移出最近最少使用的key进行淘汰</li>\n<li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li>\n<li>volatile-ttl：从已设置过期时间的key中，移出将要过期的key</li>\n<li>volatile-random：从已设置过期时间的key中，随机选择key淘汰</li>\n<li>allkeys-random：从key中随机选择key进行淘汰</li>\n<li>no-eviction：禁止淘汰数据。当内存达到阈值的时候，新写入操作报错</li>\n<li>volatile-lfu：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰(LFU(Least Frequently Used)算法，也就是最频繁被访问的数据将来最有可能被访问到)</li>\n<li>allkeys-lfu：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key。</li>\n</ul>\n<p><strong>Redis 突然挂了怎么解决？</strong></p>\n<p>答案：1、从系统可用性角度思考，Redis Cluster引入主备机制，当主节点挂了后，自动切换到备用节点，继续提供服务。2、Client端引入本地缓存，通过开关切换，避免Redis突然挂掉，高并发流量把数据库打挂。</p>\n<p><strong>Redis 持久化有哪些方式？</strong></p>\n<p>答案：</p>\n<p>1、快照RDB。将某个时间点上的数据库状态保存到<code>RDB文件</code>中，RDB文件是一个压缩的二进制文件，保存在磁盘上。当Redis崩溃时，可用于恢复数据。通过<code>SAVE</code>或<code>BGSAVE</code>来生成RDB文件。</p>\n<ul>\n<li>SAVE：会阻塞redis进程，直到RDB文件创建完毕，在进程阻塞期间，redis不能处理任何命令请求。</li>\n<li>BGSAVE：会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。</li>\n</ul>\n<p>2、只追加文件AOF。以日志的形式记录每个写操作（非读操作）。当不同节点同步数据时，读取日志文件的内容将写指令从前到后执行一次，即可完成数据恢复。</p>\n<p><strong>Redis 常用场景</strong></p>\n<p>答案：</p>\n<ul>\n<li>1、缓存，有句话说的好，「性能不够，缓存来凑」</li>\n<li>2、分布式锁，利用Redis 的 setnx</li>\n<li>3、分布式session</li>\n<li>4、计数器，通过incr命令</li>\n<li>5、排行榜，Redis 的 有序集合</li>\n<li>6、其他</li>\n</ul>\n<p><strong>Redis 缓存要注意的七大经典问题？</strong></p>\n<p>答案：列举了亿级系统，高访问量情况下Redis缓存可能会遇到哪些问题？以及对应的解决方案。</p>\n<ul>\n<li>1、缓存集中失效</li>\n<li>2、缓存穿透</li>\n<li>3、缓存雪崩</li>\n<li>4、缓存热点</li>\n<li>5、缓存大Key</li>\n<li>6、缓存数据的一致性</li>\n<li>7、数据并发竞争预热</li>\n</ul>\n<p><strong>Redis 集群方案有哪几种？</strong></p>\n<p>答案：</p>\n<ul>\n<li>主从复制模式</li>\n<li>Sentinel（哨兵）模式</li>\n<li>Redis Cluster模式</li>\n</ul>\n<p><strong>Redis 主从数据同步（主从复制）的过程？</strong></p>\n<p>答案：</p>\n<ul>\n<li>1、slave启动后，向master发送sync命令</li>\n<li>2、master收到sync之后，执行bgsave保存快照，生成RDB全量文件</li>\n<li>3、master把slave的写命令记录到缓存</li>\n<li>4、bgsave执行完毕之后，发送RDB文件到slave，slave执行</li>\n<li>5、master发送缓冲区的写命令给slave，slave接收命令并执行，完成复制初始化。</li>\n<li>6、此后，master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性</li>\n</ul>\n<p><strong>主从复制的优缺点？</strong></p>\n<p>答案：</p>\n<p>1、优点：</p>\n<ul>\n<li>master能自动将数据同步到slave，可以进行读写分离，分担master的读压力</li>\n<li>master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>不具备自动容错与恢复功能，master 节点宕机后，需要手动指定新的 master</li>\n<li>master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题</li>\n<li>难以支持在线扩容，Redis的容量受限于单机配置</li>\n</ul>\n<p><strong>Sentinel（哨兵）模式的优缺点？</strong></p>\n<p>答案：哨兵模式基于主从复制模式，增加了<strong>哨兵来监控</strong>与<strong>自动处理故障</strong>。</p>\n<p>1、优点：</p>\n<ul>\n<li>哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有</li>\n<li>master 挂掉可以自动进行切换，系统可用性更高</li>\n</ul>\n<p>2、缺点：</p>\n<ul>\n<li>Redis的容量受限于单机配置</li>\n<li>需要额外的资源来启动sentinel进程</li>\n</ul>\n<p><strong>Redis Cluster 模式的优缺点？</strong></p>\n<p>答案：实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。</p>\n<p>1、优点：</p>\n<ul>\n<li>无中心架构，数据按照slot分布在多个节点</li>\n<li>集群中的每个节点都是平等的，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。</li>\n<li>可线性扩展到1000多个节点，节点可动态添加或删除</li>\n<li>能够实现自动故障转移，节点之间通过<code>gossip协议</code>交换状态信息，用投票机制完成slave到master的角色转换</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>数据通过异步复制，不保证数据的强一致性</li>\n<li>slave充当 “冷备”，不对外提供读、写服务，只作为故障转移使用。</li>\n<li>批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好</li>\n<li>key事务操作支持有限，只支持多key在同一节点的事务操作，多key分布在不同节点时无法使用事务功能</li>\n<li>不支持多数据库空间，一台redis可以支持16个db，集群模式下只能使用一个，即<code>db 0</code>。Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。</li>\n</ul>\n<p><strong>Redis 如何做扩容？</strong></p>\n<p>答案：为了避免数据迁移失效，通常使用<code>一致性哈希</code>实现动态扩容缩容，有效减少需要迁移的Key数量。</p>\n<p>但是Cluster 模式，采用固定Slot槽位方式（16384个），对每个key计算CRC16值，然后对16384取模，然后根据slot值找到目标机器，扩容时，我们只需要迁移一部分的slot到新节点即可。</p>\n<p><strong>Redis 的集群原理?</strong></p>\n<p>答案：一个redis集群由多个节点node组成，而多个node之间通过<code>cluster meet</code>命令来进行连接，组成一个集群。</p>\n<p>数据存储通过分片的形式，整个集群分成了<code>16384</code>个slot，每个节点负责一部分槽位。整个槽位的信息会同步到所有节点中。</p>\n<p>key与slot的映射关系：</p>\n<ul>\n<li>健值对 key，进行 <code>CRC16</code> 计算，计算出一个 16 bit 的值</li>\n<li>将 16 bit 的值对 16384 取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽</li>\n</ul>\n<p><strong>Redis 如何做到高可用？</strong></p>\n<p>答案：哨兵机制。具有自动故障转移、集群监控、消息通知等功能。</p>\n<p>哨兵可以同时监视所有的主、从服务器，当某个master下线时，自动提升对应的slave为master，然后由新master对外提供服务。</p>\n<p><strong>什么是 Redis 事务？</strong></p>\n<p>答案：Redis事务是一组命令的集合，将多个命令打包，然后把这些命令按顺序添加到队列中，并且按顺序执行这些命令。</p>\n<p>Redis事务中没有像Mysql关系型数据库事务隔离级别的概念，不能保证原子性操作，也没有像Mysql那样执行事务失败会进行回滚操作</p>\n<p><strong>Redis 事务执行流程？</strong></p>\n<p>答案：通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。</p>\n<p>具体过程：</p>\n<ul>\n<li>服务端收到客户端请求，事务以<code>MULTI</code>开始</li>\n<li>如果正处于事务状态时，则会把后续命令放入队列同时返回给客户端<code>QUEUED</code>，反之则直接执行这 个命令</li>\n<li>当收到客户端的<code>EXEC</code>命令时，才会将队列里的命令取出、顺序执行，执行完将当前状态从事务状态改为非事务状态</li>\n<li>如果收到 <code>DISCARD</code> 命令，放弃执行队列中的命令，可以理解为Mysql的回滚操作，并且将当前的状态从事务状态改为非事务状态</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>WATCH 监视某个key，该命令只能在MULTI命令之前执行。如果监视的key被其他客户端修改，EXEC将会放弃执行队列中的所有命令。UNWATCH 取消监视之前通过WATCH 命令监视的key。通过执行EXEC 、DISCARD 两个命令之前监视的key也会被取消监视。</p></blockquote>\n<p><strong>Redis 与 Guava 、Caffeine 有什么区别？</strong></p>\n<p>答案：缓存分为本地缓存和分布式缓存。</p>\n<p>1、Caffeine、Guava，属于本地缓存，特点：</p>\n<ul>\n<li>直接访问内存，速度快，受内存限制，无法进行大数据存储。</li>\n<li>无网络通讯开销，性能更高。</li>\n<li>只支持本地应用进程访问，同步更新所有节点的本地缓存数据成本较高。</li>\n<li>应用进程重启，数据会丢失。</li>\n</ul>\n<p>所以，本地缓存适合存储一些不易改变或者低频改变的高热点数据。</p>\n<p>2、Redis属于分布式缓存，特点：</p>\n<ul>\n<li>集群模式，支持大数据量存储</li>\n<li>数据集中存储，保证数据的一致性</li>\n<li>数据跨网络传输，性能低于本地缓存。但同一个机房，两台服务器之间请求跑一个来回也就需要500微秒，比起其优势，这点损耗完全可以忽略，这也是分布式缓存受欢迎的原因。</li>\n<li>支持副本机制，有效的保证了高可用性。</li>\n</ul>\n<p><strong>如何实现一个分布式锁？</strong></p>\n<p>答案：</p>\n<ul>\n<li>1、数据库表，性能比较差</li>\n<li>2、使用Lua脚本 (包含 SETNX + EXPIRE 两条指令)</li>\n<li>3、SET的扩展命令（SET key value [EX][PX] [NX|XX]）</li>\n<li>4、Redlock 框架</li>\n<li>5、Zookeeper Curator框架提供了现成的分布式锁</li>\n</ul>\n","text":"为了便于大家查找问题，了解全貌，整理个目录，我们可以快速全局了解关于Redis 缓存，面试官一般喜欢问哪些问题？ 接下来，我们逐条来看看每个问题及答案 Redis 有哪些特性？ 答案： 性能高， 读的速度是100000次&#x2F;s，写的速度是80000次&#x2F;s 数据持...","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"Redis","slug":"Redis","count":9,"path":"api/categories/Redis.json"}],"tags":[{"name":"redis","slug":"redis","count":9,"path":"api/tags/redis.json"}],"toc":"","author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"控制并发","uid":"f9a9c6facd4e5bfb5a48d022643ffd1d","slug":"01_MySQL/控制并发","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:01.992Z","comments":true,"path":"api/articles/01_MySQL/控制并发.json","keywords":null,"cover":null,"text":"Mysql内部通过锁机制实现对资源的并发访问控制，保证数据的一致性，锁机制的类型和引擎的种类有关，MyISAM中默认支持的表级锁有两种：共享读锁和独占写锁。表级锁在MyISAM和InnoDB的存储引擎中都支持，但是InnoDB默认支持的是行锁。 MyISAM锁机制Mysql中可以...","link":"","photos":[],"count_time":{"symbolsCount":728,"symbolsTime":"1 mins."},"categories":[{"name":"SQL","slug":"SQL","count":15,"path":"api/categories/SQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":16,"path":"api/tags/MySQL.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"Redis 队列消费","uid":"dc39dd35ae294923e1738eec2083266a","slug":"02_Redis/Redis消息队列","date":"2019-03-20T07:05:07.000Z","updated":"2022-10-05T13:38:02.009Z","comments":true,"path":"api/articles/02_Redis/Redis消息队列.json","keywords":null,"cover":null,"text":" 数据结构 list - 先进先出 - 左进右出 归纳 实现方式 操作 效果 单list 左进右出 lpush rpop 最简单，实际应用比较局限 多list brpop list1 list2 0 推荐用法，实际应用最为合适 特定单list list1 - 高优list2 - ...","link":"","photos":[],"count_time":{"symbolsCount":727,"symbolsTime":"1 mins."},"categories":[{"name":"Redis","slug":"Redis","count":9,"path":"api/categories/Redis.json"}],"tags":[{"name":"redis","slug":"redis","count":9,"path":"api/tags/redis.json"}],"author":{"name":"Michael","slug":"michael","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"Just Do IT","socials":{"github":"https://github.com/mikeah2011","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"https://weibo.com/u/7318914058","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"https://juejin.cn/user/1873223546578589","customs":{"bilibili":{"icon":"http://localhost:4000/svg/bilibili.svg","link":"https://live.bilibili.com/22619211"},"baidu":{"icon":"iconfont icon-baidu","link":"https://live.bilibili.com/22619211"},"book":{"icon":"far fa-address-book","link":"https://live.bilibili.com/22619211"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}